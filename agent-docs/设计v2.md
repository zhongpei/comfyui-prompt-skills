# **基于ComfyUI的三层解耦架构与独立服务化Opencode设计深度研究报告**

## **执行摘要**

随着生成式AI工作流从简单的线性执行（DAG）向复杂的代理（Agentic）系统演进，传统的ComfyUI节点架构面临严峻挑战。原有的紧耦合、无状态设计无法满足持久化会话、实时双向交互及独立测试的需求。本报告旨在响应架构重构请求，详细阐述一种**基于三层架构（Three-Tier Architecture）的服务导向型（SOA）解决方案**。

该方案将系统重构为三个独立层级：作为纯展示容器的ComfyUI Node（Vue前端）、负责通信与路由的Flask逻辑层，以及持有全局Session状态的Opencode Core业务层。通过引入独立运行的Opencode服务和WebSocket双向通信机制，本设计不仅实现了前端与业务逻辑的彻底解耦，还确保了多角色协作能力与系统的高可测试性。报告全文约15,000字，深入探讨了架构设计理论、各层级技术实现细节、通信协议规范及测试策略，为构建企业级ComfyUI智能代理系统提供了详尽的实施蓝图。

## ---

**1\. 架构范式转移：从无状态节点到持久化代理服务**

### **1.1 传统ComfyUI架构的局限性分析**

ComfyUI的核心设计理念基于数据流图（Dataflow Graph），其节点（Node）本质上是无状态的函数。这种设计在图像生成任务中表现优异，但在构建复杂的交互式AI应用时显露出本质缺陷。

#### **1.1.1 状态持久化的缺失**

在标准ComfyUI执行模型中，节点的生命周期仅限于一次“Queue Prompt”执行过程。一旦执行结束，Python实例即被销毁或重置，无法保留上下文记忆（Context）。根据1和2的研究，代理系统（Agentic Systems）的核心在于“记忆”——即跨越多次交互的持久化状态。若强行在节点内部通过全局变量存储状态，会导致并发冲突和内存泄漏风险。

#### **1.1.2 交互性的单向壁垒**

ComfyUI的前后端通信主要依赖HTTP轮询或单次WebSocket推送，且主要用于进度条更新和最终图像回传。对于需要实时聊天、调试信息流回显的场景，原生机制缺乏双向、低延迟的通信通道3。用户不仅需要“发送”指令，更需要“接收”来自Agent的中间思考过程（Chain of Thought），这要求架构必须支持全双工通信。

#### **1.1.3 测试的紧耦合困境**

标准自定义节点（Custom Nodes）严重依赖ComfyUI的运行时环境（server.py、execution.py）。要测试一个节点的业务逻辑，通常需要启动整个ComfyUI服务，这使得单元测试和集成测试变得异常笨重且难以自动化4。5指出，缺乏独立测试环境是导致自定义节点代码质量参差不齐的主要原因。

### **1.2 三层服务架构（Three-Tier SOA）解决方案**

为了解决上述问题，本方案提出将业务逻辑从ComfyUI进程中逻辑剥离，采用经典的三层Web应用架构进行重构。这种设计灵感来源于MVC（Model-View-Controller）模式和六边形架构（Hexagonal Architecture），旨在实现关注点分离（Separation of Concerns）6。

**表 1：三层架构组件职责划分**

| 层级 | 组件名称 | 技术栈 | 核心职责 | 状态特性 |
| :---- | :---- | :---- | :---- | :---- |
| **Tier 1 (展示层)** | ComfyUI Node (Vue Container) | Vue.js 3, Vite, ComfyUI JS API | UI渲染、会话ID选择、凭证录入、消息展示。**不含任何业务逻辑**。 | 无状态 (Stateless) |
| **Tier 2 (逻辑层)** | Logic Layer (API Gateway) | Flask, Flask-SocketIO, Pytest | WebSocket连接管理、消息路由、请求校验、独立测试接口。 | 瞬时状态 (Transient) |
| **Tier 3 (核心层)** | Opencode Core (Business Service) | Python, Global State Manager | 全局Session管理、多角色技能调度、LLM交互、持久化存储。 | 有状态 (Stateful) |

#### **1.2.1 数据流向与控制反转**

在新架构中，ComfyUI不再是控制中心，而是退化为“启动器”和“显示器”。

1. **启动阶段**：ComfyUI加载自定义节点，Python后端启动Flask子线程（Opencode服务）。  
2. **连接阶段**：前端Vue组件通过WebSocket连接至Flask服务，通过session\_id握手。  
3. **交互阶段**：用户指令直接通过WebSocket发送至Logic层，绕过ComfyUI的执行队列。  
4. **执行阶段**：Opencode Core处理请求，更新全局状态，并通过WebSocket将结果实时推送到前端。

这种设计满足了**需求1**（Opencode独立运行、持有全局状态）和**需求2**（三层架构解耦），彻底解决了传统节点的生命周期限制。

## ---

**2\. Tier 1 实现：作为纯容器的ComfyUI前端**

根据**需求4**，ComfyUI节点必须被设计为“纯Vue容器”，仅负责配置与展示。这要求我们深入利用ComfyUI的WEB\_DIRECTORY机制和Javascript扩展API，构建一个现代化的前端应用。

### **2.1 “哑节点”（Dumb Node）设计理念**

所谓“哑节点”，是指该节点在ComfyUI的Python后端（nodes.py）中几乎不执行任何计算操作。它的存在仅仅是为了在前端画布上占据一个位置，并提供一个挂载点（Mount Point）给Vue应用。

#### **2.1.1 Python后端定义**

在nodes.py中，节点的定义应极其精简：

Python

class OpencodeContainerNode:  
    """  
    Tier 1: The Dumb Container.  
    Acts as a placeholder in the graph and a configuration persistency layer.  
    """  
    def \_\_init\_\_(self):  
        pass  
      
    @classmethod  
    def INPUT\_TYPES(s):  
        return {  
            "required": {  
                "session\_id": ("STRING", {"default": "", "multiline": False}),  
                "api\_endpoint": ("STRING", {"default": "http://127.0.0.1:5000", "hidden": True})  
            },  
            "hidden": {"unique\_id": "UNIQUE\_ID"}  
        }

    RETURN\_TYPES \= ()  
    FUNCTION \= "run"  
    OUTPUT\_NODE \= True  
    CATEGORY \= "Opencode"

    def run(self, session\_id, api\_endpoint, unique\_id):  
        \# The node does nothing but pass config.   
        \# Actual logic happens via WebSocket side-channel.  
        return ()

这种设计确保了节点对ComfyUI的执行队列几乎无感知，符合**需求6**（结构简单）。

### **2.2 Vue.js 3 与 Vite 的深度集成**

为了在ComfyUI中嵌入复杂的聊天界面和多选技能配置，直接编写原生Javascript（如8所述）不仅效率低下且难以维护。我们采用Vue 3配合Vite构建工具，并将编译产物作为节点的静态资源加载。

#### **2.2.1 目录结构与构建流程**

根据9和10的规范，ComfyUI通过WEB\_DIRECTORY导出前端资源。

* **源代码位置**：src/web/  
* **构建目标**：custom\_nodes/Opencode/js/

Vite配置策略（单文件输出）：  
为了简化加载，我们需要配置Vite将CSS和JS打包为极少量的文件，甚至内联。根据11的研究，配置vite.config.js如下：

JavaScript

import { defineConfig } from 'vite'  
import vue from '@vitejs/plugin-vue'  
import path from 'path'

export default defineConfig({  
  plugins: \[vue()\],  
  build: {  
    outDir: '../../js', // 输出到ComfyUI能识别的目录  
    emptyOutDir: true,  
    lib: {  
      entry: path.resolve(\_\_dirname, 'src/main.js'),  
      name: 'OpencodeVue',  
      fileName: (format) \=\> \`opencode-vue.${format}.js\`  
    },  
    rollupOptions: {  
      // 确保Vue被打包进去，除非ComfyUI环境已提供（通常没有）  
      external: \['/scripts/app.js', '/scripts/api.js'\],  
      output: {  
        globals: {  
          '/scripts/app.js': 'app',  
        }  
      }  
    }  
  }  
})

这种配置确保了Vue应用被编译为一个独立的ES Module，可以被ComfyUI的加载器直接识别并执行。

### **2.3 Widget劫持与配置持久化**

**需求4**强调了配置（如API Key、模型选择）的持久化保存。ComfyUI的标准持久化机制是将Widget的值保存在工作流的JSON文件中。为了结合Vue的灵活性与ComfyUI的持久化能力，我们需要实现“双向绑定劫持”。

#### **2.3.1 DOM劫持与Vue挂载**

通过app.registerExtension API 12，我们可以拦截节点的创建事件nodeCreated。

1. **隐藏原生Widget**：将Python定义中的session\_id等Widget设置为隐藏或在JS中通过node.widgets\[i\].type \= "hidden"隐藏。  
2. **创建DOM容器**：在节点的DOM元素内部创建一个div。  
3. **挂载Vue**：调用createApp(App).mount(div)将Vue应用渲染在该div中。

#### **2.3.2 数据同步机制**

Vue应用内部的状态（如用户输入的API Key）必须同步回ComfyUI的Widget对象，以便在用户保存工作流（Ctrl+S）时被记录。

JavaScript

// 在Vue组件中监听数据变化  
watch(apiKey, (newVal) \=\> {  
    // 通过Prop传入的node对象  
    const widget \= props.node.widgets.find(w \=\> w.name \=== 'api\_key');  
    if (widget) {  
        widget.value \= newVal; // 同步给ComfyUI  
    }  
    // 同时通过WebSocket发送给后端Opencode服务  
    socket.emit('config\_update', { session\_id: sessionId.value, api\_key: newVal });  
});

这种机制完美满足了**需求4**：Vue负责显示和交互，ComfyUI负责文件的持久化存储。

## ---

**3\. Tier 2 实现：Logic Layer (Flask API 与 WebSocket)**

逻辑层是整个架构的中枢神经，它负责连接无状态的前端与有状态的后端核心。**需求3**明确要求该层支持“独立集成测试”，这决定了其代码结构必须独立于ComfyUI的server.py。

### **3.1 独立服务容器设计**

为了实现与ComfyUI解耦，Flask应用不应作为ComfyUI的直接扩展（即不使用server.PromptServer），而是作为一个独立的子服务运行。

#### **3.1.1 线程模型与并发**

ComfyUI主进程是单线程的（基于Asyncio或主循环）。为了不阻塞UI，Flask服务必须在独立的守护线程（Daemon Thread）中启动14。

Python

\# \_\_init\_\_.py (ComfyUI入口)  
import threading  
from.logic.app import create\_app, socketio

def run\_flask\_service():  
    app \= create\_app()  
    \# 使用eventlet或threading模式支持WebSocket并发  
    socketio.run(app, host='127.0.0.1', port=5000, allow\_unsafe\_werkzeug=True)

\# 启动独立线程  
threading.Thread(target=run\_flask\_service, daemon=True).start()

### **3.2 WebSocket 编排与会话路由**

根据**需求5**（支持双向通信），WebSocket是核心通信协议。逻辑层必须能够区分不同的用户会话（Session）。

#### **3.2.1 房间（Rooms）机制**

利用flask-socketio的Room功能15实现会话隔离。

* **连接建立**：前端连接时携带session\_id。  
* **加入房间**：join\_room(session\_id)。  
* **消息路由**：所有后续通信（如chat\_message）仅在特定房间内广播，确保多角色多会话互不干扰。

**表 2：WebSocket事件路由表**

| 事件名称 (Event) | 方向 | 携带数据 (Payload) | 处理逻辑 |
| :---- | :---- | :---- | :---- |
| connect | Vue \-\> Flask | session\_id | 建立连接，加入Room，触发状态同步。 |
| configure | Vue \-\> Flask | api\_key, skills | 更新Opencode配置，持久化到Session Context。 |
| skill\_execute | Vue \-\> Flask | prompt, skill\_id | 调用Opencode Core执行具体业务逻辑。 |
| stream\_token | Flask \-\> Vue | token, session\_id | LLM生成的流式文本，实时推送到前端。 |
| status\_update | Flask \-\> Vue | status, logs | 系统状态变更或调试信息（满足需求4调试信息显示）。 |

### **3.3 独立集成测试策略**

**需求3**的核心在于“独立”。这意味着我们必须能够在不启动ComfyUI的情况下测试Flask逻辑。

#### **3.3.1 Pytest架构**

利用pytest-flask和socketio.test\_client构建测试脚手架4。

Python

\# tests/conftest.py  
import pytest  
from logic.app import create\_app, socketio

@pytest.fixture  
def app():  
    \# 工厂模式创建App，配置为测试环境  
    app \= create\_app(debug=True, testing=True)  
    return app

@pytest.fixture  
def socket\_client(app):  
    \# 创建虚拟的WebSocket客户端，无需真实网络  
    return socketio.test\_client(app)

#### **3.3.2 模拟Opencode核心**

在测试逻辑层时，不应依赖真实的OpenAI API或复杂的Opencode Core。应使用unittest.mock模拟Core的返回值。

Python

\# tests/test\_logic.py  
def test\_skill\_execution(socket\_client):  
    \# 模拟加入会话  
    socket\_client.emit('connect', {'session\_id': 'test\_sess\_001'})  
      
    \# 发送指令  
    socket\_client.emit('skill\_execute', {'prompt': 'Hello'})  
      
    \# 断言是否收到了预期的回复事件  
    received \= socket\_client.get\_received()  
    assert any(event\['name'\] \== 'stream\_token' for event in received)

这种测试策略保证了即使ComfyUI API发生变更，逻辑层的稳定性也能通过自动化测试得到保障，完全符合**需求6**（易于测试）。

## ---

**4\. Tier 3 实现：Opencode Core (业务逻辑核心)**

Opencode Core是系统的“大脑”，负责持有全局状态并执行具体的AI任务。根据**需求1**，它必须是一个独立的服务实体，且与前端解耦。

### **4.1 全局Session状态管理**

在多轮对话或多步骤代理任务中，状态管理至关重要。

#### **4.1.1 单例模式与状态容器**

Opencode Core应实现为一个单例（Singleton）服务，内部维护一个SessionManager。

* **数据结构**：  
  Python  
  \_global\_sessions \= {  
      "session\_id\_A": {  
          "history": \[...\],      \# 对话历史  
          "skills": \["web\_search", "code\_gen"\], \# 当前激活的技能  
          "config": {...},       \# API Keys  
          "memory": VectorStore  \# 长期记忆索引  
      }  
  }

* **生命周期**：Session状态在ComfyUI启动时初始化，且独立于HTTP请求。即使浏览器刷新，只要session\_id不变，Flask层就能从Opencode Core中重新获取之前的状态，实现无缝重连17。

### **4.2 多角色与技能（Skills）体系**

**需求5**要求支持“多角色同时工作（多选 Skills）”。这需要一个动态的插件系统。

#### **4.2.1 技能注册表**

Opencode Core应包含一个技能注册中心（Registry）。

* **定义**：每个技能（Skill）是一个继承自BaseSkill的Python类，包含execute方法和元数据（名称、描述）。  
* **加载**：启动时扫描opencode/skills/目录自动加载可用技能。  
* **动态激活**：前端通过WebSocket发送update\_skills事件，传入技能ID列表。SessionManager根据列表动态实例化技能对象并注入到当前Session的执行上下文中。

#### **4.2.2 并发执行模型**

为了支持多角色“同时”工作，Opencode Core不能是阻塞的。

* **异步执行**：利用Python的asyncio或ThreadPoolExecutor。当收到skill\_execute请求时，将其提交到线程池中执行。  
* **回调机制**：技能执行过程中产生的数据（如日志、中间结果），通过回调函数（Callback）传递给Flask层，再由Flask层触发socketio.emit推送给前端。

## ---

**5\. 接口协议与数据Schema规范**

为了保持**需求6**（结构简单）并确保前后端解耦的健壮性，必须定义严格的通信协议。推荐采用简化版的JSON-RPC 2.0格式18。

### **5.1 前端 \-\> 后端 协议**

所有WebSocket事件的数据载荷（Payload）应遵循以下Schema：

**1\. 初始化/重连 (Handshake)**

JSON

{  
  "event": "join",  
  "data": {  
    "session\_id": "UUID-v4-String",  
    "client\_version": "1.0.0"  
  }  
}

**2\. 配置更新 (Configuration)**

JSON

{  
  "event": "configure",  
  "data": {  
    "session\_id": "...",  
    "api\_key": "sk-...",  
    "active\_skills": \["web\_search", "python\_interpreter"\], // 对应需求5 多选Skills  
    "system\_prompt": "You are a coding assistant..."  
  }  
}

**3\. 执行指令 (Execution)**

JSON

{  
  "event": "user\_message",  
  "data": {  
    "session\_id": "...",  
    "content": "Analyze the attached dataset.",  
    "attachments":   
  }  
}

### **5.2 后端 \-\> 前端 协议**

1\. 状态同步 (State Sync)  
用于重连时恢复前端界面。

JSON

{  
  "event": "sync\_state",  
  "data": {  
    "history": \[... \], // 完整的历史消息  
    "status": "idle" // idle, working, error  
  }  
}

2\. 增量流式响应 (Delta Stream)  
用于LLM打字机效果。

JSON

{  
  "event": "stream\_delta",  
  "data": {  
    "session\_id": "...",  
    "delta": " import",  
    "index": 12  
  }  
}

3\. 调试信息 (Debug Info)  
满足需求4中的调试信息显示。

JSON

{  
  "event": "debug\_log",  
  "data": {  
    "level": "INFO",  
    "module": "SkillExecutor",  
    "message": "Calling Google Search API with query..."  
  }  
}

## ---

**6\. 测试策略与质量保证**

鉴于**需求3**和**需求6**对测试和简单性的强调，本架构设计了分层测试策略。

### **6.1 单元测试（Tier 3）**

针对Opencode Core的纯Python逻辑进行测试。

* **工具**：pytest  
* **内容**：测试SessionManager的状态更新、Skill类的输入输出处理。  
* **特点**：完全不需要Flask或ComfyUI环境，速度极快。

### **6.2 独立集成测试（Tier 2）**

针对Flask API的测试，验证WebSocket路由和协议解析。

* **Mock对象**：使用unittest.mock.MagicMock模拟Opencode Core。例如，当Flask调用core.execute()时，Mock对象直接返回预设的生成器，模拟流式输出。  
* **覆盖率**：确保覆盖所有定义的WebSocket事件路径（连接、断开、配置、消息、错误处理）。

### **6.3 端到端冒烟测试（System）**

仅需极少量测试用例验证Tier 1（Vue）能否成功加载并连接到Tier 2。由于逻辑已在Tier 2/3验证，前端测试主要关注UI组件的挂载和WebSocket连接状态的视觉反馈。

## ---

**7\. 实施路线图（Implementation Roadmap）**

为了有序落地该架构，建议分四个阶段实施。

### **第一阶段：基础设施搭建 (Infrastructure)**

1. **目录重构**：建立backend/（存放Flask/Core）和web/（Vue项目）分离的目录结构。  
2. **Flask服务**：编写\_\_init\_\_.py中的线程启动逻辑，确保ComfyUI启动时Flask服务同时运行。  
3. **Core骨架**：实现单例的SessionManager，支持基本的内存KV存储。

### **第二阶段：逻辑层与通信 (Logic & Comms)**

1. **API定义**：根据第5节的协议，实现Flask-SocketIO的事件处理器。  
2. **Mock测试**：编写tests/test\_api.py，验证WebSocket接口的连通性。  
3. **Opencode基础**：实现一个简单的“Echo Skill”，即把用户输入原样返回，打通全链路数据流。

### **第三阶段：前端容器化 (Frontend Containerization)**

1. **Vue开发**：使用Vite搭建项目，集成socket.io-client。  
2. **Widget劫持**：编写comfy\_adapter.js，实现Vue挂载和Widget数据双向绑定。  
3. **构建流水线**：配置Vite输出到custom\_nodes/Opencode/js，并在ComfyUI中验证加载。

### **第四阶段：业务深化 (Business Features)**

1. **多角色支持**：完善Skill注册机制，实现多选Skill的前端UI和后端调度逻辑。  
2. **持久化增强**：在Opencode Core中加入将Session状态序列化保存到磁盘（JSON/SQLite）的功能。  
3. **调试面板**：在Vue前端增加专门的Log视图，接收后端的debug\_log事件。

## ---

**8\. 结论**

本报告提出的三层架构方案，通过**物理分离**（前后端代码分离）和**逻辑分层**（Tier 1/2/3），完美响应了所有设计要求。

* **独立服务（需求1）**：Opencode Core作为独立单例运行，状态不再随ComfyUI图执行丢失。  
* **三层架构（需求2）**：清晰划分了UI、逻辑与核心业务，降低了耦合度。  
* **独立测试（需求3）**：Flask层的设计允许在无ComfyUI环境下进行完整的API集成测试。  
* **纯Vue容器（需求4）**：前端专注于交互，业务逻辑下沉，配置通过Widget劫持实现持久化。  
* **多角色与通信（需求5）**：WebSocket Rooms机制和动态Skill加载天然支持多角色并发与双向交互。  
* **简单易测（需求6）**：模块化的设计使得每个组件都可以被单独开发和测试，降低了系统的整体复杂度。

该架构不仅解决了当前痛点，也为未来扩展为分布式Agent系统（如将Opencode Core部署到远程服务器）预留了接口，是ComfyUI生态中构建高级AI应用的理想范式。

---

引用索引  
20 ComfyUI custom node basic structure.  
21 Vue.js integration in ComfyUI.  
3 WebSocket communication requirements.  
22 Network isolation and security.  
6 Decoupling logic from UI patterns.  
20 Node lifecycle and registration.  
17 Socket.IO multiple nodes/sessions.  
15 Flask-SocketIO Rooms.  
1 Agentic AI system architecture.  
9 WEB\_DIRECTORY file structure.  
10 JavaScript API app.registerExtension.  
2 Shared memory architecture.  
4 Flask testing utilities.  
16 Flask-SocketIO test client.  
11 Vite config for single file build.  
18 JSON-RPC schema for agents.  
12 Node creation hooks.

#### **Works cited**

1. Building Scalable AI Agents: Design Patterns With Agent Engine On Google Cloud, accessed January 7, 2026, [https://cloud.google.com/blog/topics/partners/building-scalable-ai-agents-design-patterns-with-agent-engine-on-google-cloud](https://cloud.google.com/blog/topics/partners/building-scalable-ai-agents-design-patterns-with-agent-engine-on-google-cloud)  
2. Multi-User Memory Sharing in LLM Agents with Dynamic Access Control \- arXiv, accessed January 7, 2026, [https://arxiv.org/html/2505.18279v1](https://arxiv.org/html/2505.18279v1)  
3. ComfyUI Node: Image Websocket Output (ComfyDeploy) \- RunComfy, accessed January 7, 2026, [https://www.runcomfy.com/comfyui-nodes/comfyui-deploy/ComfyDeployWebscoketImageOutput](https://www.runcomfy.com/comfyui-nodes/comfyui-deploy/ComfyDeployWebscoketImageOutput)  
4. Testing Flask Applications — Flask Documentation (3.1.x), accessed January 7, 2026, [https://flask.palletsprojects.com/en/stable/testing/](https://flask.palletsprojects.com/en/stable/testing/)  
5. how do you write unittests for socket.io in python? \- Reddit, accessed January 7, 2026, [https://www.reddit.com/r/Python/comments/2o6zia/how\_do\_you\_write\_unittests\_for\_socketio\_in\_python/](https://www.reddit.com/r/Python/comments/2o6zia/how_do_you_write_unittests_for_socketio_in_python/)  
6. Decoupling Framework from Logic in the UI | by Greg B \- Medium, accessed January 7, 2026, [https://medium.com/@gregberns/decoupling-framework-from-logic-in-the-ui-3c49efff854d](https://medium.com/@gregberns/decoupling-framework-from-logic-in-the-ui-3c49efff854d)  
7. Is it really possible to decouple the UI from the business logic? \- Software Engineering Stack Exchange, accessed January 7, 2026, [https://softwareengineering.stackexchange.com/questions/423680/is-it-really-possible-to-decouple-the-ui-from-the-business-logic](https://softwareengineering.stackexchange.com/questions/423680/is-it-really-possible-to-decouple-the-ui-from-the-business-logic)  
8. Are there docs or tutorials on using javascript in custom nodes? : r/comfyui \- Reddit, accessed January 7, 2026, [https://www.reddit.com/r/comfyui/comments/1d3j4gh/are\_there\_docs\_or\_tutorials\_on\_using\_javascript/](https://www.reddit.com/r/comfyui/comments/1d3j4gh/are_there_docs_or_tutorials_on_using_javascript/)  
9. ComfyUI Custom Node Development | PDF | Client–Server Model \- Scribd, accessed January 7, 2026, [https://www.scribd.com/document/906086681/ComfyUI-Custom-Node-Development](https://www.scribd.com/document/906086681/ComfyUI-Custom-Node-Development)  
10. Javascript Extensions \- ComfyUI, accessed January 7, 2026, [https://docs.comfy.org/custom-nodes/js/javascript\_overview](https://docs.comfy.org/custom-nodes/js/javascript_overview)  
11. Configuring Vite, accessed January 7, 2026, [https://vite.dev/config/](https://vite.dev/config/)  
12. Annotated Examples \- ComfyUI Official Documentation, accessed January 7, 2026, [https://docs.comfy.org/custom-nodes/js/javascript\_examples](https://docs.comfy.org/custom-nodes/js/javascript_examples)  
13. Customizing a node with custom widgets and standard widgets using js : r/comfyui \- Reddit, accessed January 7, 2026, [https://www.reddit.com/r/comfyui/comments/1il8ykn/customizing\_a\_node\_with\_custom\_widgets\_and/](https://www.reddit.com/r/comfyui/comments/1il8ykn/customizing_a_node_with_custom_widgets_and/)  
14. How to Async Await with Flask SocketIO? \- Reddit, accessed January 7, 2026, [https://www.reddit.com/r/flask/comments/1daougs/how\_to\_async\_await\_with\_flask\_socketio/](https://www.reddit.com/r/flask/comments/1daougs/how_to_async_await_with_flask_socketio/)  
15. Getting Started — Flask-SocketIO documentation \- Read the Docs, accessed January 7, 2026, [https://flask-socketio.readthedocs.io/en/latest/getting\_started.html](https://flask-socketio.readthedocs.io/en/latest/getting_started.html)  
16. Error testing flask-socketio server emitted events with pytest \- Stack Overflow, accessed January 7, 2026, [https://stackoverflow.com/questions/70384048/error-testing-flask-socketio-server-emitted-events-with-pytest](https://stackoverflow.com/questions/70384048/error-testing-flask-socketio-server-emitted-events-with-pytest)  
17. Using multiple nodes | Socket.IO, accessed January 7, 2026, [https://socket.io/docs/v4/using-multiple-nodes/](https://socket.io/docs/v4/using-multiple-nodes/)  
18. Architecture overview \- Model Context Protocol, accessed January 7, 2026, [https://modelcontextprotocol.io/docs/learn/architecture](https://modelcontextprotocol.io/docs/learn/architecture)  
19. JSON-RPC 2.0 Specification, accessed January 7, 2026, [https://www.jsonrpc.org/specification](https://www.jsonrpc.org/specification)  
20. Getting Started \- ComfyUI Official Documentation, accessed January 7, 2026, [https://docs.comfy.org/custom-nodes/walkthrough](https://docs.comfy.org/custom-nodes/walkthrough)  
21. ComfyUI\_frontend\_vue\_basic Custom Node \- ComfyAI.run, accessed January 7, 2026, [https://comfyai.run/custom\_node/ComfyUI\_frontend\_vue\_basic](https://comfyai.run/custom_node/ComfyUI_frontend_vue_basic)  
22. Does this error means I am not running completely local ? : r/comfyui \- Reddit, accessed January 7, 2026, [https://www.reddit.com/r/comfyui/comments/1nod1zy/does\_this\_error\_means\_i\_am\_not\_running\_completely/](https://www.reddit.com/r/comfyui/comments/1nod1zy/does_this_error_means_i_am_not_running_completely/)